# Разные типы константной сложности
Допустим есть vector в C++ и действие push_back() - имеет амортизированно O(1)

1 элемент
2 элемента
4 элемента
и тд.

В худшем случае - переходит половина
Всего будет $\log_{2}(n)$ аллокаций
На одну аллокацию $O(2^i)$ - для одной переменной

$1+2+4+\dots+2^{\log_{2}N}$
$\frac{2^{\log_{2}N}-1}{2-1}=N-1$
N операций - O(N); O(N/N) ~ O(1) амортизированно (худшая из аморт оценок)

Отдельные операции могут быть дорогими, но в среднем по серии операций каждая стоит O(1).

В среднем O(1):
unordered_set::find() - при хорошей хеш-функции и равномерном распределении элементов каждая операция в типичном случае выполняется за константное время.

В худшем случае O(1): 
vector::operator[] - гарантированно константное время при любых входных данных и состояниии контейнера. Прямой доступ по индексу всегда одинаково быстр.

TCP протокол: пример арифметического роста и геометрического падения.
Посылаем какое-то кво пакетов в сеть и ждем уведомления о прибытии. Постепенно увеличиваем и если видим, что много утечек - резко уменьшаем кво сообщений.
# Ульман - изоморфизм графов
Графы изоморфны, если они по сути являются одним графом, представленным в разных формах.
![[Pasted image 20250529180447.png]]
В обоих случаях каждая вершина смежна с каждой другой, так что это две изоморфные копии.
![[Pasted image 20250529180537.png]]

Графы G и H изоморфны если, в функции F: V(G) -> V(H) соблюдаются условия:
- v является смежным с w в G
- f(v) является смежным с f(w) в H
Те вершины одного графа должны совпадать с другими, также должна сохраняться смежность.

**Задача поиска изоморфоного подграфа**
На вход даются два графа. Нужно определить, не содержит ли один граф подграф, изоморфный второму графу. 

**Применение**
- Проектирование электронных схем: проверка эквивалентности различных представлений схемы, для оптимизации
- Оптимизация программ: выделение общих подвыражений в коде для повышения эффективности
- Компьютерное зрение: беспилотник без средств навигации, кроме камеры. Допустим он куда-то прилетел и ему необходимо куда-то улететь, он считывает изображение и картинка может быть сведена к графу. Другой беспилотник делает свое изображение и свой граф, по которому маршрутизируется. Изоморфизм используется для поиска и сравнения объектов на изображениях, распознавания структур.
- Химия и биология: изоморфизм используется для сравнения и идентификации молекулярных структур. Те молекулярные структуры представляются в виде графов. Биология - проверка идентичности белков и прочих структур.
- Безопасность: есть цепочка транзакций, которая является мошеннической операцией. Сравнивая другие цепочки транзакций с данной, можно выявить другие мошеннические схемы.
# Алгоритм Ульмана
Алгоритм Ульмана - изоморфизм подграфа. NP-полная задача.
Строим матрицу смежности, она будет заполнена только {0, 1}.

![[Drawing 2025-05-29 18.18.17.excalidraw]]

	   1 2 3 4 5 6 7 8 
	a 1 1 0 0 1
	b   0 1 1 1
	c 1 1 1
	d
	g 0 0 0 1 0 0 0
	k
	i
	j

1. Инициализация
	$B(i, j)=p(v_{i}, w_{j})$
	B(i, j) = 0, если степень вершины $v_{i}$ меньше степени вершины $w_{j}$ 
	B(i, j) = 0, если есть другие основания полагать, что вершина $v_{i}$ не может соответствовать вершине $w_{j}$
2. Пусть B(i, j) = 1. Выполним поиск от вершины $v_{i}$, принимая во внимание текущее состояние матрицы B и функцию q. В результате либо будет найден изморфный подграф, либо будет доказано, что вершина $v_{i}$ не может соответствовать вершине $w_{j}$. 
(Причем каждая строка должна содержать только одну 1, а каждый столбец - не более одной 1.)
Заполняем только то, что может потенциально быть изоморфно друг другу.
Один из критериев: степень инцидентности вершин. (В примере используем критерий i(a) >= i(1))

Берем первую попавшуюся единицу, начинаем обход одного из графов и проверяем, является ли степень инцидентных вершин такой же, чтобы считать изоморфных соседей истинными соседями графа.

Те если вершина изоморфна, то ее соседи тоже должны быть изоморфны, с той же степенью вершины или больше.
Если перемножить матрицы - можно увидеть допустимость одной вершины из другой через промежуточные за сколько-то шагов.

Перебираем все матрицы, которые можно получить из начальной, удалив одну 1 из каждой строки, оставив максимум 1 единицу в каждом столбце - делаем это рекурсивно.
Получается алгоритм полного перебора, иного способа решить задачу нет.

**Сложность алгоритма**
$O(N!*N^3)$
 (Современные алгоритмы считаются хорошими, если сложность кубическая)

