Алгоритм Кнута-Морриса-Пратта - алгоритм поиска подстроки в строке.
Дан текст T и образец P. Требуется найти все позиции, начиная с которых P входит в T. 
Построим строку S=P#T, где # - любой символ, не входящий в алфавит P и T. Посчитаем на ней значение префикс-функции p. Благодаря разделительному символу, выполняется $∀i:p[i]⩽|P|$. Заметим, что по определению префикс-функции при i > |P| и p[i]=|P| подстроки длины P, начинающиеся с позиций 0 и i-|P|+1 совпадают. Соберем все такие позиции i-|P|+1 строки S, вычтем из каждой позиции |P|+1 и это будет ответом. Те если в какой-то позиции i выполняется условие p[i]=|P|, в этой позиции начинается очередное вхождение образца в цепочку.

Префикс-функция - массив длин наибольших бордеров для каждой позиции этой строки. 
Здесь и далее считаем, что символы в строках нумеруются с 0.
Определим префикс-функцию от строки s в позиции i следующим образом: $\pi(s, i)=max_{k=1\dots i}(k: s[0\dots k-1]=s[i-k+1\dots i])$. Если мы не нашли такого k, то $\pi(s, i)=0$.

Бордер строки b - строка a: b=ya=an, те префикс-суффикс строки.

**Идея КМП**
Пусть есть строки P, T:
1. Вычисляем префикс-функцию строки P#T
2. Проходим по индексам от 0 до длины строки T - 1
3. На каждом шаге цикла если $\pi[p_{1}+i+1]==p_{1}$, где p1 - длина P, то answer[count++]=i-p1

Время работы: префикс-функция от строки S строится за O(S)=O(P+T). Проход цикла по строке S содержит O(T) итераций - итого время работы O(P+T).
Оценка по памяти O(P+T), можно добиться O(P), если хранить занчения префикс-функции для позиций в S, меньших |P|+1.

**Построение префикс-функции**
Наивный алгоритм - вычисляет префикс-функцию непосредственно по определению, сравнивая префиксы и суффиксы строк. Обозначим длину строки за n. Будем считать, что префикс-функция хранится в массиве p.
```
int[] prefixFunction(string s):
     int[] p = int[s.length]
     fill(p, 0)
     for i = 0 to s.length - 1
         for k = 0 to i - 1
             if s[0..k] == s[i - k..i]
                 p[i] = k
     return p
```

Время работы: всего $O(n^2)$ итераций цикла, на каждой из которых происходит сравнение строк за O(n), в итоге дает - $O(n^3)$.

Эффективный алгоритм: вносятся несколько замечаний:
- Заметим, что p[i+1] <= p[i] + 1. Чтобы показать это, рассмотрим суффикс, оканчивающийся на позиции i+1 и имеющий длину p[i+1], удалив из него последний символ, мы получим суффикс, оканчиваюшийся на позиции i и имеющий длину p[i+1]-1
- Избавимся от явных сравнений строк. Пусть мы вычислили p[i], тогда если s[i+1] = s[p[i]], то p[i+1]=p[i]+1. Если окажется, что $s[i+1]\neq s[p[i]]$, нужно попытаться попробовать подстроку меньшей длины. Хотелось бы сразу перейти к такому бордеру наибольшей длины, для этого подберем такое k, что k=p[i] - 1. Делаем это так: за исходное время k необходимо взять p[i-1], что следует из первого пункта, в случае, когда символы s[k] и s[i] не совпадают, p[k-1] - следующее потенциальное наибольшее значение k. Последнее утверждение верно, пока k > 0, что позволит всегда найти его следующее значение. Если k=0, то p[i]=1 при s[i]=s[1], иначе p[i]=0.

![[Pasted image 20250529151311.png]]
```
int[] prefixFunction(string s):
  p[0] = 0
  for i = 1 to s.length - 1
      k = p[i - 1]
      while k > 0 and s[i] != s[k]
          k = p[k - 1]
      if s[i] == s[k]
          k++
      p[i] = k
  return p
```
Время работы алгоритма составит O(n), заметим, что итоговое количество итераций цикла while определяет асимптотику алгоритма. Теперь стоит отметить, что k увеличивается на каждом шаге не более чем на единицу, значит максимально возможное значение k=n-1. Тк внутри цикла while значение k лишь уменьшается, получается, что k суммарно не может уменьшиться больше, чем n-1 раз. Тогда цикл while выполняется в итоге не более n раз.