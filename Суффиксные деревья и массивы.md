# Суффиксные деревья
Суффиксное дерево - оптимизация суффиксного бора. 
Строим дерево для текста.
Суффиксное дерево T для строки s - дерево с n листьями (|s|=n), обладающее свойствами:
- каждая внутренняя вершина дерева имеет не менее двух детей
- каждое ребро помечено непустой подстрокой строки s
- никакие два ребра, выходящие из одной вершины, не могут иметь пометок, начинающихся с одного и того же символа
- дерево должно содержать все суффиксы строки s, причем каждый суффикс заканчивается точно в листе

Проблема:
Рассмотрим дерево для строки xabxa: суффикс xa является префиксом суффикса xabxa, тогда этот суффикс не заканчивается в листе. Для решения в конце строки s добавляют символ, не входящий в исходный алфавит - защитный символ, обозначим его $. Любой суффикс строки с защитным символом действительно заканчивается только в листе, тк в такой строке нет двух разных подстрок одинаковой длины, заканчивающейся на $. $ - неявные вершины, указатель терминальных вершин.

Сложность поиска O(|P|), сложность построения O(|T|), память $O(|T|^2)$ (пример худшего случая - много узлов с единственным ребенком, без оптимизации квадратичная память). Сложность построения для различных алгоритмов: наивный $O(n^3)$, оптимизированный наивный $O(n^2)$ (использует хеш-таблицы для переходов), алгоритм Укконена/МакКрейта: O(n). 

Пример:
T= abacaba
![[Drawing 2025-05-31 00.08.59.excalidraw]]

Сжатое суффиксное дерево - ребра содержат целые подстроки (бамбук в одну подстроку).
![[Drawing 2025-05-31 00.19.59.excalidraw]]

Можно еще сжать по структуре данных - хранить не подстроки, а индекс начала подстроки в исходном тексте
![[Drawing 2025-05-31 00.29.35.excalidraw]]

Суффиксов линейное число (не больше, чем символов в строке), в худшем случае получим полное бинарное дерево, в котором  N - 1 листьев. Память O(|T|).
Наивное суффиксное дерево - без спец символа. 
# Суффиксные массивы
Суффиксный массив строки [1...n] - массив suf целых чисел от 1 до n такой, что суффикс $s[suf[i]\dots n]$ - i-й в лексикографическом порядке среди всех непустых суффиксов строки s.
 ![[Pasted image 20250531004243.png]]
Получаем на вход некую строку.
Делаем бинарный поиск по первой букве. И первым же шагом мы можем понять, в какой половине списка дальше стоит искать. 
Сложность O(log|T|). 

**Оптимизация поиска по lcp**
В дереве можно построить некие группы и объединить их по lcp (длина наибольшего общего префикса), те не имеет смысла для шаблона убирать по одной букве, можно сравнивать сразу по lcp.

Условие 1: $max(|i|,|j|)⩾min(|i|,|j|)+|s|$
Условие 2: $|s|=min_{k=i′…j′}lcp[k]$
Будем перебирать всевозможные подстроки s строки t такие, что они входят в t дважды и удовлетворяют условию 2 при любых i, j, где i, j - суффиксы, соответствующие двум любым вхождениям s в t. Для каждой такой строки s попробуем найти i, j, удовлетворяющие условию 1. 
Оценка в худшем случае O(|p|) - за счет lcp.

**Применение**
Суффиксные деревья обычно применяют на небольшом алгоритме. Например, поиск ДНК (AGTC). Строку данных переносят в структуру и там осуществляют поиск.
Для больших алгоритмов - суффиксные массивы. 
