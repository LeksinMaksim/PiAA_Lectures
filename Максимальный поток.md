# Алгоритм Форда-Фалкерсона 
(тот же, что в [[Жадные алгоритмы]])
Сложность алгоритма зависит от максимального потока и количества вершин.
Алгоритм зависит от весов ребер.

Идея алгоритма: изначально величине потока присваивается значение 0: $f(u, v) = 0$, для всех u, v из V. Затем величина потока итеративно увеличивается посредством поиска увеличивающего пути (путь от источника s к стоку t), вдоль которого можно послать ненулевой поток. Данный поиск можно осуществить обходом в глубину или в ширину. Процесс повторяется, пока можно найти увеличивающий путь.

Обратные ребра служат для отмены ранее пущенного потока, чтобы в конечном итоге увеличить поток. Они позволяют графу остаточного потока быть симметричным, те если поток уходит из вершины A в вершину B, то можно пустить поток и обратно. Если идем по обратному ребру, уменьшаем поток.

S-T разрез - разделение всех вершин графа V на два непересекающихся множества так, что:
- Источник принадлежит S множеству
- Сток принадлежит T множеству
- S - множество вершин, достижимых из S
- T - множество вершин, достижимых из T

Пропускная способность разреза - сумма пропускных способостей всех ребер, где первое принадлежит S множеству, второе T множеству.

Любой поток из S в T должен пересечь любой S-T разрез, те величина макс потока не может превышать пропускную способность любого S-T разреза. Тогда макс поток не может быть больше, чем пропускная способность минимального S-T разреза (с наименьшей пропускной способностью).
Величина макс потока из S в T равна пропускной способности мин S-T разреза.

При завершении алгоритма в остаточном графе больше нет увеличивающих путей и можно построить конкретный S-T разрез, где величина макс потока соответсвует описанному выше свойству. 

Сложность алгоритма, если величина пропускной способности - неизвестно, если целые числа $O(|E|f)$, E - число ребер в графе, f - макс поток в графе, тк каждый увеличивающий путь может быть найден за O(E) и увеличивает поток как минимум на 1.
# Алгоритм Гольдберга (проталкивания предпотока)

Алгоритм относится к алгоритмам с разметкой по высотам, те высотным

**Идея push-relabel алгоритмов**
Вместо того, чтобы искать целый путь от источника до стока и увеличивать поток вдоль него, алгоритмы работают более локально:
- используется предпоток
- допускается, что входящй поток в вершину может превышать исходящий
- понятие избыточного потока
- цель алгоритма - избавиться от избыточных потоков
- у каждой вершины есть высота
- есть две операции - проталкивание и подъем

Поток - функция f: V x V -> R, удовлетворяющая свойствам:
- f(u, v) = -f(v, u) - антисимметричность
- f(u, v) <= c(u, v) - ограничение пропускной способности
- $∑_{v}f(u,v)=0$ - закон сохранения потока (кроме истока и стока), причем используя св 1 можно понять, что это разность между суммой потока по входящим ребрам и суммой потока по исходящим ребрам, это же имеется в виду везде дальше при рассмотрении

Предпоток - функция f: V x V -> R, удовлетворяющая свойствам:
- f(u, v) = -f(v, u) - антисимметричность
- f(u, v) <= c(u, v) - ограничение пропускной способности
- $∀u∈V∖{s,t}∑_{v∈V}f(v,u)⩾0$ - ослабленное условие сохранения потока

Избыточным потоком, входящим в вершину u, назовем величину $e(u)=∑_{v∈V}f(v,u)$. Тогда вершина $u∈V∖{s,t}$ будет называться переполненной, если e(u) > 0.
![[Pasted image 20250601165413.png]](B - переполненная, A - исток, D - сток)

Функция h: V -> Z+ называется высотой вершины, если она удовлетворяет условиям:
- h(s)=|V|
- h(t)=0
- $∀(u,v)∈E_{f}$  $h(u)⩽h(v)+1$, $E_{f}$ - остаточная сеть

Пусть дан граф G, в котором выделены две вершины: исток S и сток T, а у каждого ребра определена пропускная способгость C(u, v). Поток F можно представить как поток вещества, которое могло бы пройти по сети от истока к стоку, если рассматривать граф как сеть труб с некоторыми пропускными способностями. Те поток - функция F(u, v), определенная на множестве ребер графа. Необходимо найти макс поток. 

**Проталкивание**
Может применяться тогда, когда вершина u является переполненной, $c_{f}(u, v)>0$, $h(u)=h(v)+1$, $c_{f}$ - остаточная пропускная способность, на каждом шаге при проталкивании она обновляется в зависимости от f

По ребру (u, v) пускается минимально возможный поток, те минимум из избытка вершины u и остаточной пропускной способности ребра (u, v), вследствие чего избыток вершины u, остаточная пропускная способность ребра (u, v) и поток по обратному ребру уменьшаются на величину потока, а избыток вершины v, поток по ребру и остаточная пропускная способность обратного ребра увеличиваются на ту же величину.
```
function push(Node u, Node v)
    d = min(e(u), c(u, v) - f(u, v))
    f(u, v) += d
    f(v, u) = -f(u, v)
    e(u) -= d
    e(v) += d
```
Проталкивание из вершины u в вершину v насыщающее, если после него остаточная пропускная способность ребра (u, v) стала равна 0. Остальные проталкивания - ненасыщающие.

**Подъем**
Операция подъема применима для вершины u, если e(u) > 0 и $∀(u,v)∈E_{f}:$ $h(u)⩽h(v)$. Те для переполненной вершины u применима операция подъема, если все вершины, для которых в остаточной сети есть ребра из u, расположены не ниже u. Тогда операцию проталкивания для вершины u нельзя произвести. Остаточная сеть состоит из прямых ребер, если $c_{f}>0$, и обратных, если поток по прямому > 0.

В результате подъема высота текущей вершины становится на единицу больше высоты самой низкой смежной вершины в остаточной сети, из-за чего появляется хотя бы одно ребро, по которому можно протолкнуть поток.
```
function relabel(Node u)
	h(u)=min{h(v): f(u, v) - c(u, v) < 0} + 1
```
**Cхема алгоритма**
Проинициализируем предпоток. Пропустим максимально возможный поток по ребрам, инцидентным истоку, увеличив избыточный поток для каждой смежной с источником вершиной на соответствующую величину. Все остальные потока не несут, те для вершин не смежных с истоком избыточный поток изначально будет нулевым. Также для всех вершин кроме истока установим нулевую высоту.
![[Pasted image 20250601171159.png]]

После инициализации выполняем операции проталкивания и подъема в произвольном порядке. Утверждается, что кво данных операций конечно и после завершения алгоритма предпоток становтся максимальным потоком. 

**Инварианты** - свойства, которые сохраняются на протяжении всего выполнения алгоритма
1. $h(s)=|V|$
2. $h(t) = 0$
3. $h(u)\leq h(v)+1$ - для любого допустимого ребра (u, v) в остаточной сети
4. e(v) >= 0 для всех v из V кроме S, T
5. f(u, v) <= c(u, v) и f(u, v) = -f(v, u)

**Сложность**
Любая реализация метода для сети завершает работу за $O(V^2E)$ операций.
Алгоритм Форда-Фалкерсона зависит от величины потока, в отличие от данного алгоритма. У этого метода лучшая асмиптотическая сложность в худшем случае для обычных графов. 
Высота каждой вершины кроме s, t ограничена сверху 2|V|-1, каждая операция поднятия ув высоту минимум на 1, те каждая вершина может быть поднята O(|V|) раз (округлим 2|V|-1 до |V| для простоты). Всего |V| вершин, так что общее кво операций поднятия O(|V|^2). Каждая операция поднятия требует просмотра всех ребер, исходящих из поднимаемой вершины, что в сумме по всем поднятиям для одной вершины дает O(|V| x кво инц ребер), итого стоимость всех поднятий O(|V||E|). 
Насыщающее проталкивание происходит по ребру (u, v), когда h(u)=h(v)+1, после чеге c(u, v) = 0. Чтобы по тому же ребру снова можно было сделать насыщающее протакливание, должен произойти поток по обратному ребру, что требует h(v) = h(u) + 1, тте либо h(u) уменьшилось (невозможно), либо h(v) увеличилось как минимум на 2. Тк высоты ограничены O(|V|), каждое ребро может участвовать в насыщающем проталкивании O(|V|) раз, всего |E| ребер, так что кво насыщ проталкиваний O(|V||E|). Пусть $Ф=\sum_{u:e(u)>0}h(u)$, поднятие увеличивает Ф не более чем на O(|V|), общее увеличение  O(|V|^3). Насыщающее проталкивание - может сделать v активной, увеличивает Ф не более, чем на O(|V|), общее увеличение O(|V|^2|E|). 
Ненасыщающее проталкивание - делает u неакивной, уменьшая Ф минимум на 1, может сделать v активной, увеличивая Ф на h(v)=h(u)=1, те каждое ненасыщающее проталкивание уменьшает Ф минимум на 1. Тк Ф начинается с 0 и не может ыть отрицательной, а общее увеличение Ф от поднятия и насыщающего проталкивания ограничено O(|V|^2|E|), то и кво ненасыщающих проталкиваний также ограничено O(|V|^2|E|). Каждая операция проталкивания и поднятия занимает O(1) времени. 
Итого по времни O(|V|^2|E|).
Пространственная сложность - хранение графа и остаточной сети O(|V|+|E|) для списков смежности, массивы для f(u, v), e(u), h(v) - если хранить для всех пар O(|V|^2), если только для существующих ребер, O(|E|), e(u) и h(v) - по O(|V|). Если поток f(u, v) хранится для всех пар - $O(|V|^2)$, если же представление на основе списков смежности для потока по сущетсвующим ребрам и их обратным, то $O(|V|+|E|)$. 
 
**Доказательство корректности**
Докажем, что при завершении алгоритма полученный предпоток является допустимым потоком и что он максимальный.

Для доказательства используем описанные выше инварианты.

Алгоритм завершается, когда нет активных вершин кроме S, T, те избыточный поток e(v)=0 для всех промежуточных вершин. Тк алгоритм поддерживает свойства предпотока, итоговый предпоток является допустимым потоком.
Из ключевого инварианта высот следует, что при завершении алгоритма не существует пути от S к T в остаточном графе. Пусть  x - множество вершин, достижимых из S в остаточном графе, T в этом множестве нет, тогда S-T разрез: (X, V \ X). 
Все ребра из X в V \ X в исходном графе насыщены потоком, иначе v было бы достижимо из S. Все ребра из V \ X в X в исходном графе имеют нулевой поток, иначе v было бы достижимо из S через обратное ребро. 
Величина потока $|f|=\sum c(u, v) (X \to V / X)-0=capacity(X, V / X)$. По теореме о макс потоке и мин разрезе, если величина потока равна пропускной способности некоторого разреза, он максимален.

