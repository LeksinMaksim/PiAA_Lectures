Жадный алгоритм - заключающийся в принятии локально оптимальных решений на каждом этапе, допуская, что конечное решение также окажется оптимальным.
# Минимальное остовное дерево
На каждом шаге выбираем ребро минимального веса, проверяем на цикл. Можно и Прима и Краскала.
Краскала: сортируем ребра по возрастанюи весов, выбираем на каждом шаге ребро с мин весом еще не рассмотренное, добавляем в МОД, если не образует цикл.
Прима: с произвольной вершины, на каждом шаге выбираем ребро мин веса, которое соединяет вершину из построенного МОД с вершиной не из МОД, добавляем ребро в МОД и вершину.
[[Задача о коммивояжере]]
![[Pasted image 20250529013035.png]]
# Задача о расписании
Необходимо максимизировать количество выполненных работ $(S_{i}, f_{i})$
![[Drawing 2025-05-29 01.31.43.excalidraw]]
(0, 16)- s1, (4, 64) - s2, (2, 32) - s3, (18, 20) - s4

Если отсортировать отрезки по возрастанию начала и добавлять их в решение в таком поядке - некорректный алгоритм решения. Это особенно заметно на больших отрезках, например (-1, 100).

Вместо этого надо отсортировать по времени окончания: $S_{1}, S_{4}, S_{3}, S_{2}, S_{5}(-1, 100)$

На каждом шаге алгоритма выбираем отрезок с минимальным значением правой границы и убираем все пересекающиеся с ним, затем повторяем выбор.

Можно доказать, что если набор непересекающихся отрезков не содержит лучший отрезок по времени окончания, то при замене первого отрезка в наборе на лучший получится набор непересекающихся отрезков.

У лучшего отрезка время окончания самое малое. Тк в наборе находятся непересекающиеся отрезки, то их времена начала и окончания не пересекаются. Получается, что конец лучшего отрезка не превышает конец первого и начало второго. Тогда конец лучшего отрезка не превышает начало второго и отрезок не пересекается со вторым. Аналогично для каждого отрезка, тк в наборе они упорядочены и не пересекатся.
# Алгоритм Хаффмана
Алгоритм Хаффмана - алгоритм оптимального префиксного кодирования алфавита. 

Пусть $A={a_{1}, a_{2},  \dots, a_{n}}$ - алфавит из n различных символов, $W={w_{1}, w_{2}, \dots, w_{n}}$ - соответствующий ему набор положительных целых весов. Тогда набор бинарных кодов $C={c_{1}, c_{2}, ..., c_{n}}$, где ci - код для символа ai, такой, что:
- ci не является префиксом для cj, $i \neq j$
- $∑_{i∈[1,n]}w_{i}⋅|c_{i}|$ минимальна
Набор называется кодом Хаффмана.

Построение кода Хаффмана сводится к построению соответствующего бинарного дерева:
1. Составление списка кодируемых символов, притом рассматриваем один символ как дерево из одного элемента с весом, равным частоте появления символа в строке
2. Из списка выбираем два узла с наименьшим весом
3. Сформируем новый узел с весом, равным сумме весов выбранных узлов, и присоединим к нему два выбранных узла в качестве детей
4. Добавим к списку только что сформированный узел вместо двух объединенных узлов
5. Если в списке больше одного узла, повторим п.2-п.5
6. В конце для каждого символа выбираем кодовое слово

Если сортировать элементы после каждого суммирования или использовать приоритетную очередь, алгоритм работает за $O(N\log N)$ (можно улучшить до O(N) использованием обычных массивов). Если очередь строится путем последовательных вставок, каждая вставка занимает O(logk) времени, k - текущий размер очереди, всего n листовых узлов необходимо вставить = в сумме O(nlogn), если очередь строится из массива за O(n) - O(n). Основной цикл построения дерева - выполняется n-1 раз, в каждой итерации: два извлечения минимума, каждая из которых заннимает O(logk), одна вставка нового узла занимает O(logn). Пространственная - O(n), тк хранение частот, приоритетная очередь, дерево.

Пример:
A - 70, B - 3,  C - 20, D - 37

![[Drawing 2025-05-29 01.57.50.excalidraw]]

# Задача о рюкзаке

Дано N предметов, W - вместимость рюкзака, $w=(w_{1}, w_{2}, \dots, w_{N})$ - соответствующий ему набор положительных целых весов, $p=(p_{1}, p_{2}, \dots, p_{N})$ - соответствующий ему набор положительных целых стоимостей. Нужно найти набор бинарных величин $B=b_{1}, b_{2}, \dots, b_{N}$, где bi = 1, если предмет ni включен в набор, bi=0 если предмет ni не включен и такой, что:
- $b_{1}w_{1}+⋯+b_{N}w_{N}⩽W$
- $b_{1}p_{1}+⋯+b_{N}p_{N}$ максимальна

Можно решить несколькими способами:
- Перебирать все подмножества набора из N предметов - $O(2^N)$
- Методом дп - $O(NW)$

Жадная стратегия - на каждом шаге выбирать лучший по какому-то критерию предмет. Например, цена за кг; предметы с максимальной стоимостью; минимальный вес. (Макс стоимость - можно взять какой-то очень дорогой, но тяжелый предмет, который займет весь рюкзак; мин вес - можно набрать много легких, но дешевых предметов)

Пример:
вместимость рюкзака - 50кг, предметы (вес/цена):
- 10/60; 6 р/кг
- 20/100; 5 р/кг
- 30/120; 4 р/кг

Такой стратегией получим, что в рюкзаке будут предметы 1 и 2, что очевидно не самый лучший результат. Стратегия не всегда дает корректное решение
# Потоки в графах (алг Форда-Фалкерсона)
Рассматриваем взевешенные графы с истоком и стоком.
Необходимо максимизировать поток в графе, те пропустить максимальное кво жидкости через граф так, чтобы оно добралось до стока.

У каждой вершины есть своя пропускная способность.
В любом разрезе будет оптимальное количество жидкости. Макс поток s->t - пропускная способность мин s-t разреза.
![[Pasted image 20250601120930.png]]
![[Pasted image 20250601115732.png]]

Изначально величине потока присваивается значение 0: f(u, v)=0 для всех u, v из V. Затем величина потока итеративно увеличивается посредством поиска увеличивающего/дополняющего пути (путь от источника s к стоку t, вдоль которого можно послать ненулевой поток). Этот путь можно искать обходом в глубину или в ширину. Пропускаем по пути максимально возможный поток (остаточная пропускная способность), для прямых ребер - уменьшаем остаточные пропускные способности ребер, для обратных - уменьшаем поток, увеличиваем остаточную пропускную способность. Процесс повторяется, пока можно найти увеличивающий путь в остаточной сети. 

Во время поиска также появляются обратные ребра - по которым можно идти в обратном направлении (если по ним уже пропущен поток и его можно уменьшить). Позволяют алгоритму исправляьб неудачные жадные выборы, сделанные на предыдущих шанах.

Если величина пропускной способности - иррациональное число, алгоритм будет работать бесконечно. В целых числах время работы ограничено $O(|E|f)$, где E - число ребер в графе, f - максимальный поток в графе, тк каждый увеличивающий поток может быть найден за O(|E|) и увеличивает поток как минимум на 1. O(|E|) - тк нахождение пути через обход занимает O(|V|+|E|), тк ребер может быть до 2|E| (обратные). Тк макс поток конечен, алгоритм выполнит не более f операций. Пространственная сложность O(|V|+|E|)=O(|E|), для представления графа и остаточной сети по спискам смежности O(|V|+|E|), очередь для BFS или стек для DFS, массивы для отметки посещенных вершин, хранения пути - до O(|E|).
# Принцип доказательства оптимальности работы жадного алгоритма

Говорят, что к оптимизационной задаче применим принцип жадного выбора, если последовательность локально оптимальных выборов дает глобально оптимальное решение. В типичном случае доказывается по такой схеме:
- Доказывается, что жадный выбор на первом шаге не закрывает пути к оптимальному решению: для всякого решения есть другое, согласованное с жадным выбором и не хуже первого
- Показывается, что подзадача, возникающая после жадного выбора на первом шаге, аналогична исходной
- Рассуждение завершается по индукции

Говорят, что задача обладает свойством оптимальности для подзадач для выведения результата, если оптимальное решение задачи содержит в себе оптимальные решения для всех ее подзадач. 

