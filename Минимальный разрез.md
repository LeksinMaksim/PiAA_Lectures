# Понятие

Наименьший разрез графа - минимальное количество ребер, удаление которых разделяет граф на две компоненты связности (или отделяет сток от истока в задачах о потоках).

![[Pasted image 20250528225545.png]]

Граф с n вершинами может иметь не более $\frac{n(n-1)}{2}$ различных наименьших разрезов.
# Практические задачи

Примеры задач, где используется минимальный разрез:
- Транспортные сети: найти минимальную пропускную спосоность между источником и стоком в сети, что соответствует мин разрезу. Определить минимальный набор дорог, закрытие которых критически нарушит транспортную доступность. 

- Кластеризация данных: найти оптимальное разделение данных на кластеры, где минимальный разрез между кластерами означает наименьшую связь между ними. Найти тесно связанные группы людей в социальной сети.

- Компьютерное зрение и обработка изображений: разделить изображение на значимые области (объекты и фон). Вершины графа - пиксели изображения и два специальных узла (исток и сток), ребра между пикселями - вес обратно пропорционален различию в цвете или яркости, ребра к источнику или стоку - вероятность принадлежности к объекту или фону.
# Алгоритм Каргера

Алгоритм Каргера - рандомизированный алгоритм для нахождения минимального разреза в связном графе. 

Пусть G - неориентированный мультиграф с множеством вершин V и множеством ребер E, $|V|=n, |E|=m$

Стягиванием ребра uv назовем следующую последовательность действий:
1. Добавляем новую вершину w
2. Для всех ребер xu и xv ($x∈V,x≠v,x≠u$) добавляем новые ребра xw. Притом, если получаются кратные ребра - оставляем
3. Удаляем вершины u и v и все инцидентные им ребра
![[Pasted image 20250601010034.png]]

(Кратные ребра - такие, где вершины могут быть соединены более чем одним ребром. Граф с кратными ребрами - мультиграф)

![[Pasted image 20250528231146.png]]

Мультивершина - вершина, полученная из двух стягиванием ребра между ними, каждая из которых также может быть мультивершиной

Стянутый граф - состоит из двух мультивершин или одной мультивершины и одной ообычной вершины, полученный из исходного графа последовательным стягиванием произвольных ребер

Разрез - разбиение множества V на два можества A и B, удовлетворяющее таким условиям:
- $A,B⊂V$
- $A,B≠∅$
- $A∩B=∅$
- $A∪B=V$

Вес разреза обозначается w(A, B) и вычисляется как:
- для взвешенного графа: $w(A,B)=∑_{u,v∈E,u∈A,v∈B}w(uv)$
- для невзвешенного графа: $w(A,B)=|{uv:u∈A,v∈B}|$

Задача поиска разреза минимального веса среди всех возможных. Можно решить с помощью любого из алгоритмов поиска максимального потока, зафиксировав произвольную вершину s в качестве истока и запуская его O(n) раз для всех возможных стоков. При использовании быстрого алгоритма поиска за O(mn), время работы алгоритма поиска мин разреза $O(n^2m)$
# Алгоритм Каргера

Пусть дан граф $G={V, E}$

1. Есть функция, которая берет любой разрез графа (п.3) и затем сравнивает его с текущим минимумом и присваивает значение, если оно меньше.

2. Тк алгоритм вероятностный и функция возвращает вес случайного потока, а не минимального, для того, чтобы наверняка найти вес минимального, необходимо вызывать функцию count раз (столько, сколько есть разных разрезов). 

3. Пока вершин больше двух, выбираем случайное ребро и стягиваем его. Когда в графе останется две вершины, кво ребер между ними будет равно весу некоторого разреза исходного графа.

Псевдокод:
```
int minCut(G):
  answer = inf
  for i = 1 to count
    curCut = getCut(G)
    if curCut < answer
      answer = curCut
  return answer

int getCut(graph):
  G = graph 
  vertexCount = количество вершин в G
  while vertexCount > 2
    edge = случайное ребро из G
    contract(edge) //стягиваем ребро edge
    vertexCount--
  edgeCount = количество ребер в G
  return edgeCount
```

Если вызвать функцию получения разреза $n^2\ln n$ раз и после каждой итерации запоминать минимум, вероятность, что найденный ответ будет неверен $\leq\frac{1}{n^2}$. Даже при небольших значениях n алгоритм практически гарантированно выдает верный ответ.
Время работы функции нахождения разреза $O(n^2)$. Функция работает $O(n^2\log n)$ раз. Итоговое время работы: $O(n^4\log n)$
# Оптимизация Штейна алгоритма Каргера

Заметим, что вероятность стягивания вершины, принадлежащей мин разрезу, в начале поиска разреза (getCut) довольно мала, в то время, как вероятность стянуть ребро, которое не следует стягивать, ближе к концу работы функции существенно возрастает. Тогда будем использовать следующую рекурсивную версию алгоритма:

1. Ищем разрез (getCut) и стягиваем ребра до тех пор, пока не останется $\frac{n}{\sqrt{ 2 }}$ вершин

2. Запускаем независимо эту же функцию для получившегося графа дважды и возвращаем минимальный ответ

Алгоритм дает верный ответ с точностью, не менее $\frac{1}{\log(n)}$. Время работы функции getCut вычисляется рекурсивной функцией:
$T(n)=O(n^2)+2T\left( \frac{n}{\sqrt{ 2 }} \right)=O(n^2\log n)$
Что медленнее оригинального алгоритма, но вероятность нахождения разреза минимального веса экспоненциально выше. Достаточно запустить алгоритм $c\log^2n$ раз, где c - некоторая константа.

Итоговое время работы: $O(n^2\log n)*c\log^2n=O(n^2\log^3n)$
