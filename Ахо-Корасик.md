Алгоритм Ахо-Корасик - алгоритм поиска подстроки, реализует поиск множества подстрок из словаря в данной строке.

Дан набор строк в алфавите размера k, суммарной длины m. Необходимо найти для каждой строки все ее вхождения в текст.

**Бор**
Бор - структура данных для хранения набора строк, представляющая из себя подвешенное дерево с символами на ребрах. Строки получаются последовательной записью всех символов, хранящихся на ребрах между корнем бора и терминальной вершиной. Размер бора линейно зависит от суммы длин всех строк, а поиск в бору занимает время, пропорциональное длине образца - O(P).

Пример:
![[Pasted image 20250530222758.png]]

Построение: 
Введем следующие обозначения:
- $\sum$ - используемый алфавит
- $P=(P_{1}, \dots, P_{k})$ - набор строк с символами из алфавита, называемый словарем
- $n=\sum_{i=1\dots k}|P_{i}|$ - сумма длин строк

Бор храним как набор вершин, у каждой из которых есть метка, обозначающая, является ли вершина терминальной и указатели на другие вершины или на NULL

Алгоритм:
Непосредственно построение:
- Создадим дерево из одной вершины
- Добавление элементов в дерево
	- Добавляем символы шаблона $P_{i}$ один за другим. Следуем из корня по ребра, отмеченным буквами из $P_{i}$, пока возможно
	- Если $P_{i }$ заканчивается в v, сохраняем идентификатор $P_{i}$ в v и отмечаем вершину v как терминальную
	- Если ребра, отмеченного очередной буквой $P_{i}$ нет, создаем новое ребро и вершину для символа строки $P_{i}$

Построение занимает $O(|P_{1}|+\dots+|P_{k}|)=O(n)$ времени, тк поиск буквы, по которой нужно переходить, происходит за O(1)

Тк на каждую вершину приходится $O\left( |\sum| \right)$ памяти, то использование памяти есть $O\left( n|\sum| \right)$

**Автомат**
Детерминированный конечный автомат - набор из пяти элементов ($Σ,Q,s∈Q,T⊂Q,δ:Q×Σ→Q$), где $\sum$ - алфавит, Q - множество состояний, s  начальное состояие, T - множество допускающих состояний, $δ$ - функция переходов

Изначально автомат находится в стартовом состоянии s. Автомат считывает символы по очереди. При считывании очередного символа $p_{i}$ автомат переходит в состояние $δ(q,p_{i})$, где q - текущее состояние автомата. Процесс продолжается, пока не будет достигнут конец входного слова. 

Будем говорить, что автомат допускает слово, если после окончания описанного выше процесса автомат окажется в допускающем состоянии.

**Алгоритм (сам Ахо-Корасик)**
1. Построение бора
	Строим бор из строк. Построение выполняется за время O(m), m - суммарная длина строк.
	
2. Преобразование бора
   Обозначим за [u] слово, приводящее в вершину u в боре. Узлы бора можно понимать как состояния автомата, а корень как начальное состояние. Узлы бора, в которых заканчиваются строки, становятся терминальными. Для переходов по автомату заведем в узлах несколько функций:
	- parent(u) - возвращает родителя вершины u
	- $π(u)=δ(π(parent(u)),c)$ - суффиксная ссылка, и существует переход из parent(u) в u по символу c
	- $δ(u,c)=v$ - если v ребенок по символу c в боре, $δ(u,c)=root$ - если u это корень и у него нет детей по символу c в боре, $δ(u,c)=δ(\pi(u),c)$ - иначе

	Мы можем понимать ребра бора как переходы в автомате по соответсвующей букве. Если мы пытаемся выполнить переход по какой-то букве, а такого ребра в боре нет, то пользуемся суффиксными ссылками.
	
	Функция перехода:
	```
	Node getLink(Node v, char c): 
    if v.go[c] == _null_                           // если переход по символу c ещё не вычислен
        if v.son[c]
            v.go[c] = v.son[c]
        else if v == root 
            v.go[c] = root 
        else 
            v.go[c] = getLink(getSuffLink(v), c)
    return v.go[c]
	```
	
	Суффиксная ссылка $\pi(u)=v$, если [v] - максимальный суффикс [u], $[v]\neq[u]$. Функции перехода и суффиксные ссылки можно найти либо алгоритмом обхода в глубину с ленивыми вычислениями, либо с помощью алгоритма обхода в ширину.
	```
	Node getSuffLink(Node v):
	if v.suffLink == _null_                       // если суффиксная ссылка ещё не вычислена
       if v == root or v.parent == root
            v.suffLink = root
       else
            v.suffLink = getLink(getSuffLink(v.parent), v.charToParent)
    return v.suffLink
	```
	
	Это позволяет реализовать функции поиска переходов по символу и суффиксных ссылок ленивым образом при помощи взаимной рекурсии.
	(в целом концепция суффиксных ссылок здесь очень похожа на префикс-функцию, использующуюся в КМП: [[Алгоритм КМП]] ). Временная сложность построения: O(N), N - суммарная длина всех строк словаря.

3. Построение сжатых суффиксных ссылок
	При построении автомата может возникнуть такая ситуация, что ветвление есть не на каждом символе. Тогда можно маленький бамбук заменить одним ребром. Для этого и используются сжатые суффиксные ссылки.
	$up(u) =\pi(u)$ - если $\pi(u)$ терминальная, $up(u)=∅$ - если $\pi(u)$ - корень, $up(u)=up(\pi(u))$ - иначе
	где up - сжатая суффиксная ссылка, те ближайшее допускающее состояние перехода по суффиксным ссылкам. аналогично обычным суффиксным ссылкам сжатые суффиксные ссылки могут быть найдены при помощи ленивой рекурсии
```
	Node getUp(Node v):
    if v.up == _null_                             // если сжатая суффиксная ссылка ещё не вычислена
        if getSuffLink(v).isLeaf
            v.up = getSuffLink(v)
        else if getSuffLink(v) == root
            v.up = root
        else 
            v.up = getUp(getSuffLink(v))
    return v.up
```
Сложность построения сжатых суффиксных ссылок O(N), N - суммаогая длина всех строк словаря.

По очереди просматриваем символы текста. Для очередного символа c переходим из текущего состояния u в состояние, которое вернет функция $δ(u,c)$. Оказавшись в новом состоянии, отмечаем по сжатым суффиксным ссылкам строки, которые нам встретились и их позицию. Если новое состояние является терминалом, то соответствующие ему строки тоже отмечаем. Временная сложность поиска O(L+k), L - длина текста, в котором ищем, k - кво найденных вхождений всех слов из словаря в тексте. 

**Оптимизации**
Если нас интересует только первое вхождение образца в текст, существуют следующие оптимизации:
1. Сброс сжатых суффиксных ссылок для посещенных вершин.
	Пометки о посещенности узла, те если узел посещен, то не переходить по сжатым суффиксным ссылкам. Вместо хранения пометок можно просто сбрасывать сжатую суффиксную ссылку.
2. Сброс пометки терминальной вершины.
	В изначальном  множестве образцов могут быть дублирующиеся строки. Мы можем хотеть их различать, если с одинаковыми строками связана разная мета-информация. Тогда при попадании в терминальную вершину можно осуществлять сброс пометки этой терминальной вершины.

**Поиск шаблонов с масками**
Пусть $\phi$ - маска, обозначающая любой одиночный символ. Необходимо найти для каждого заданного шаблона с масками все его вхождения в текст.

Алгоритм поиска:
Чтобы найти все вхождения в текст заданного шаблона  с масками Q, необходимо обнаружить вхождения в текст всех его безмасочных кусков.

Пусть {$Q_{1}, \dots, Q_{k}$} - набор подстрок Q, разделенных масками, и пусть {$l_{1}, \dots, l_{k}$} - их стартовые позиции в Q. Для алгоритма нам понадобится массив C. C[i] - кво встретившихся в тексте безмасочных подстрок шаблона, который начинается в тексте на позиции i. Тогда появление подстроки $Q_{i}$ в тексте на позиции j будет означать возможное появление шаблона на позиции $j-l_{i}+1$.

1. Используя алгоритм Ахо-Корасик, находим безмасочные подстроки шаблона Q: когда находим $Q_{i}$ в тексте на позиции j, увеличиваем на единицу $C{j-l_{i}+1}$
2.  Каждое i, для которого C[i]=k, является стартовой позицией появления шаблона Q в тексте.

Рассмотрим подстроку текста $T[i\dots i+n-1]$. Равенство $C[i]=k$ будет означать, что подстроки текста $T[i+l_{1}\dots i+l_{1}+|Q_{1}|-1], T[i+l_{2}\dots i+l_{2}+|Q_{2}|-1]$ и так далее будут равны соответственно безмасочным подстрокам шаблона {$Q_{1}, \dots, Q_{k}$}. Остальная часть шаблона является масками, так что шаблон входит в текст на позиции i. 

Поиск подстрок заданного шаблона с помощью алгоритма Ахо-Корасик выполняется за время $O(m+n+\alpha)$, где n - суммарная длина подстрок, те длина шаблона, m - длина текста, a - кво появлений подстрок шаблона. Далее просто надо пробежаться по массиву C и просмотреть значения ячеек за время O(m).