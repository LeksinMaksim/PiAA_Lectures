Пример: алгоритм захода студентов в аудиторию N x N сверху вниз - O(1), тк сложность показывает то, как меняется число операций в зависимости от размера входных данных (здесь - от ква студентов), сложность по операциям
# Бэктрекинг

**Задача о ферзях** - есть N ферзей, доска размером N x N. Нужно расставить все ферзи так, чтобы ни один из них не находился под боем другого. Ферзь бьёт все клетки, расположенные по вертикали, горизонтали и обеим диагоналям. 

$C_{{N^2}}^N$, доска 8 x 8

1. Начало: пустая доска
2. Ставим в одну любую клетку
 - Если фигура бьёт другую - переставляем
 - Если ферзей N - решение найдено
 - Если ферзей < N - переходим к началу шага 2

условный псевдокод: 
```
while (не все решения)
	while (множество не пусто)
		двигаюсь вперел 
		if (решения)
			...
		else
			...
```

- Худшая сложность $O(C_{N^2}^N)$ ~ $4.4*10^8$, где поле 8 x 8
- Если не ставить новые фигуры в тот же столбец: $O(N^N)$ ~ $1.7*10^7$
- Если не ставить новые фигуры в ту же строку: $O(n!)$ ~ $4*10^4$
- Если не ищем все решения до конца: ~ $10^3$ (раннее отесечение, проверяем конфликты сразу при постановке)

# Подходы метода ВиГ по отсечению вариантов

Строим дерево решений, но отсекаем те ветви, которые заведомо не приведут к оптимальному решению.

Некоторые типы отсечений:
- Если нижняя граница ветви >= лучшего найденного решения. Для вычисления нижней оценки несколько методов, например текущая стоимость и минимальная стоимость остальных ребер.
- Если текущее состояние нарушает ограничения. Например конфликты с уже поставленными ферзями.
- Состояние A доминирует над состоянием B (лучше его по всем параметрам)
- Исключение симметричных вариантов (отзеркаливание). Например в задаче раскраски графа - исключаем перестановки цветов, в задаче о ферзях ставим первого верзя в левой половине - отсекаем половину пространства для поиска. 
- Используем эвристики для ранней оценки перспективности

В методе ветвей и границ, например, в качестве оптимизации используется мемоизация

![[Drawing 2025-05-28 00.57.53.excalidraw]]

Хвостовая рекурсия - особый вид рекурсии, при котором рекурсивный вызов является последней операцией, выполняемой в функции. После того как рекурсивный вызов завершается, родительской функции больше нечего делать кроме возвращения результата.

Рекурсия - метод решения задачи, когда функция вызывает саму себя для решения меньшей подзадачи того же типа, пока не будет достигнуто простое базовое условие. 

Рекурсия может быть представлена как очередь задач. 

Рекурсия может быть преобразована в итеративную - через циклы. Рекурсия обычно использует стек вызовов для зраения состояния каждого вызова функции. При преобразовании рекурсии в цикл часто приходится эмулировать такой стек, простую рекурсию можно преобразовать в простой цикл без явного стека.

Такое преобразование в задаче коммивояжера даст преимущество в производительности, не будет риска переполнения стека вызовов.  $O(d^2)\to O(d)$, d - глубина (кво уровней принятия решений в задаче, кво городов). Улучшается константа временной сложности (около 2-5 раз).

![[Метод Монте-Карло]]