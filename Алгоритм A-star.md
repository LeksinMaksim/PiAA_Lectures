# Базовые алгоритмы поиска пути

**Поиск в ширину**
Находит кратчайший путь от одной начальной вершины до всех остальных в невзвешенном графе. Кратчайший путь здесь означает путь с наименьшим квом ребер. Также используется для проверки связности.

Потребуется очередь и множество посещенных вершин was, которые изначально содержат одну вершину. На каждом шагу алгоритм берет из начала очереди вершину и добавляет все непосещенные смежные с ней вершины в множество посещенных вершин was и в конец очереди. Если очередь пуста, то алгоритм завершает работу.
![[Pasted image 20250529153216.png]]

Оценим время работы для входного графа G=(V, E), E - множество ребер, представлено списком смежности. В очередь добавляются только непосещенные вершины, так что каждая вершина посещается не более раза. Операции внесения в очередь и удаления из нее требуют O(1) времени, так что общее время работы с очередью составляет O(|V|) операций. Для каждой вершины рассматривается не более deg(v) ребер, инцидентных ей. Так как $∑_{v∈V}deg(v)=2|E|$, время, используемое на работу с ребрами, составляет O(|E|). Так что общее время работы алгоритма поиска в ширину O(|V|+|E|).

Очередь - структура данных, добавление и удаление элементов из которой происходит путем операций push и pop. Притом первым из очереди удаляется элемент, помещенный первым, принцип FIFO. У очереди есть голова и хвост. Когда элемент ставится в очередь, он занимает место в хвосте. Из очереди всегда выводится элемент из ее головы. 
Операции - проверка на пустоту, запись, снятие, кво элементов.
![[Pasted image 20250529153653.png]]

**Алгоритм Дейкстры**
Находит кратчайшие пути от одной начальной вершины до всех остальных вершин в графе с неотрицательными весами ребер. Если нужно найти путь до конкретной вершины, алгоритм можно остановить, как только эта вершина будет извлечена из очереди с приоритетом.

Жадный алгоритм - постепенно строит множество вершин, для которых кратчайший путь уже известен.
1. Каждый раз, когда мы хотим посетить новый узел, мы выберем узел с наименьшим известным расстоянием
2. Как только мы переместились в узел, мы проверяем каждый из соседних узлов. Мы вычисляем расстояние от соседних узлов до корневых, суммируя стоимость ребер, которые ведут к этому новому узлу.
3. Если расстояние до узла меньше известного расстояния, мы обновим самое короткое расстояние.

На каждом шаге существует множество уже обработанных вершин и еще не обработанных. 
```
for (v ∈ V)
	DIST[v] = ∞
	PREV[v] = ∅
DIST[v' ∈  V] = 0  // стартовая вершина
// Первый шаг:
H ← MakeQueue() // формирование очереди с приоритетами для вершины v'. Все инцидентные вершины попадают сюда
while (H ≠ ∅)
	v ← min(H) // из очереди с приоритетами выбирается минимальный DIST[v]
	for (vu ∈  E) //для каждого инцидентного ребра
		if (DIST[u] > DIST[v] + w(v,u) // если расстояние до вершины больше, чем то, по которому мы проходим - условие релаксации
			DIST[u] ← DIST[V] + w(v,u)
			PREV[u] ←
UpdatePriorities(H)
```
(релаксация ребра - попытка улучшить оценку расстояния до вершины через данное ребро)

Сложность алгоритма: худший случай - каждый путь содержит в себе все остальные вершины. Если каждый такой путь будет храниться к каждой вершине, память будет $v^2$. Для оптимизации в каждой вершине хранится не весь путь, а только предыдущая вершина, из которой можно попасть в текущую.

Общая сложность алгоритма:  $O(v^2)$ - приоритетная очередь на массиве (построение кучи за O(v), извлечение минимума $v*O(v)$, обновление расстояния O(E)), $O(E\log v)$ - приоритетная очередь на двоичной куче (построение за $v*O(\log v)$, извлечение минимума - $v*O(\log v)$, обновление расстояния - удаление+вставка - $E*O(log v)$). Если кво ребер небольшое, выгоднее использовать реализацию на куче, если же ребер намного больше, чем вершин - на массиве. Пространственная сложность - $O(v^2)$ - матрица смежности, O(v+E) - списки смежности.

**Двусторонний алгоритм Дейкстры**
1. Двусторонний алгоритм Дейкстры:
	- запустить вперед от вершины s с метками расстояния $d_{f}(v)$
	- запустить обратный от вершины t с метками расстояния $d_{r}(v)$

2. Отслеживаем текущий лучший путь: минимизация пути (релаксация) $d_{f}(v)+l(v, w)+d_{r}(w)$

3. Останавливаемся когда проходим какую-то вершину во второй раз, возвращаем лучшее расстояние.
# Алгоритм A* 
Алгоритм A* - алгоритм поиска, который находит во взвешенном графе маршрут наименьшей стоимости от начальной вершины до выбранной конечной. Обобщение Дейкстры, использующее эвристику.

**Двухэтапные алгоритмы**
Двунаправленный алгоритм Дейкстры всего в два раза быстрее обычного, что слишком медленно. Рассмотрим алгоритм поиска кратчайшего пути, состоящий из 2 этапов:
1. Препроцессинг:
	- запускается единожды для графа
	- может занимать много времени
	- рассчитывает некую вспомогательную информацию
2. Запрос:
	- может использовать данные, полученные во время препроцессинга
	- запускается по требованию для пары (s, t)
	- должен выполняться очень быстро (в реальном времени)

Нужно что-то гибкое: препроцессинг за часы/минуты, рост ква предпосчитанных данных линейно от размера графа и запросы в реальном времени (метрики).

Возьмем любую потенциальную функцию h(v), которая переводит вершины в вещественные числа, она определяет уменьшенную стоимость каждого ребра как $l_{h}(v, w)=l(v, w)-h(v)+h(w)$, l - среднее время проезда по дороге
Заметим, что замена $l$ на $l_{h}$ не изменит кратчайших путей: возьмем любой путь $P=(qs=v_{0}, v_{1}, \dots, v_{k}, v_{k+1}=t)$. Тогда $l_{h}(P)=l_{h}(s, v_{1}), l_{h}(s, v_{w})$. Тогда $l_{h}(P)=l_{h}(s,v_{1}), l_{h}(s, v_{w})$. Тогда $l_{h}(P)=l_{h}(s,v_{1})+l_{h}(v_{1},v_{2})+\dots+l_{h}(v_{k},t)=$
$=l(s,v_{1})-h(s)+h(v_{1})+l(v_{1},v_{2})-h(v_{1})+h(v_{2})+\dots+l(v_{k},t)-h(v_{k})+h(t)=$
$=l(P)-h(s)+h(t)$
Таким образом, все длины путей s->t изменятся на одну и ту же величину h(t)-h(s).

- Агоритм A* =  Дейкстры на графе $G_{h}$:
	- так же как на графе G, если l заменить на уменьшенную стоимость $l_{h}$ (стоимости ребер заменили на потенциальные)
	- на каждом шаге, выбираем v, минимизирующую $l(P_{sv})-h(s)+h(v)$
	- h(s) одинаковая для всех вершин
	- в лучшем случае $∀v:h(v)=d(v,t)$
- Эквивалент: использовать l, которая сначала сканирует самые перспективные вершины
	- возрастающая последовательность $k(v)=d(v)+h(v)$
	- k(v): предполагаемая длина кратчайшего пути s->t через v
	- d(v): оценка по dist(s, v)
	- h(v): оценка по dist(v, t)
- Для корректности необходимо $l_{h}\geq 0$:
	- потенциальная функция вычисляема
	- дает нижние границы, если $h(v)\leq0$
- Результат: целенаправленный поиск

- h(v) дает нижние границы dist(v, t)
- поведение:
	- худший случай: h(v) = 0 для всех v (эквивалентно Дейкстре)
	- лучший случай: h(v) = dist(v, t) для всех v:
		- $l_{h}(v, w) = 0$ если на кратчайшем пути s->t, иначе положительно
		- поиск посещает только кратчайший путь
	- чем уже нижняя оценка, тем меньше вершин сканируется

**Эвристическая функция** - оценка
Под эвристической функцией понимается аппарат, позволяющий выбрать тот элемент, который быстрее приведет к решению задачи. Поведение алгоритма сильно зависит от применяемой эвристики. Выбор эвристики же зачастую зависит от постановки задачи. Часто A* используется для моделирования перемещения по поверхности, покрытой координатной сеткой:
- Если мы можем перемещаться в 4 направлениях, в качестве эвристики стоит выбрать манхэттенское расстояние: $h(v)=|v.x-goal.x|+|v.y-goal.y|$
- Расстояние Чебышева применяется, когда к 4 направлениям добавляются диагонали: $h(v)=max(|v.x-goal.x|, |v.y-goal.y|)$
- Если передвижение не ограничено сеткой, то можно использовать евклидово расстояние до прямой (планарный граф): $h(v)=\sqrt{(v.x-goal.x)^2+(v.y-goal.y)^2}$

Стоит обратить внимание на то, как соотносятся f(v) и h(v). Если они измеряются в разных величинах, A* может выдать некорректный результат. Также эвристическая функция должна быть монотонна.

**Двунаправленный A-star**
Для двунаправленной версии алгоритма используем две потенциальные функции:
- прямое направление: $p_{f}(v)$, оценивающая dist(v, t)
- обратное направление: $p_{r}(v)$, оценивающая dist(s, v)

Проблема: разные потенциальные стоимости у ребер для различных обходов:
- $ℓ_{pf}(v,w)=ℓ(v,w)−p_{f}(v)+p_{f}(w)$ - если ребро обрабатывается в обходе, начатом в s
- $ℓ_{pr}(v,w)=ℓ(v,w)−p_{r}(w)+p_{r}(v)$ - если ребро обрабатывается в обходе, начатом в t

Чтобы избежать этой проблемы, необходимо, чтобы
$l_{pf}(v,w)=ℓ_{pr}(v,w)⇔p_{f}(v)+p_{r}(v)=p_{f}(w)+p_{r}(w)=const$. Кроме того, функции должны быть монотонными.

Решение - использовать усредненные потенциальные функции:
- $h_{f}(v)=\frac{p_{f}(v)−p_{r}(v)}{2}$
- $h_{r}(v)=\frac{p_{r}(v)−p_{f}(v)}{2}=−h_{f}(v)$

При таком выборе потенциальных функций, выполняется $∀u:h_{f}(u)+h_{r}(u)=0$ и тогда двунаправленный алгоритм становится аналогичен двунаправленному алгоритму Дейкстры.

**ALT**
A* + Landmarks + Triangle inequality (А* + ориентиры + неравенство треугольника)

1. Препроцессинг:
	- взять небольшое кво вершин, обозначив их как ориентиры
	- для каждого из ориентиров посчтать кратчайшие пути до всех вершин
	- сохранить эти пути
2. Запрос:
	- используем A*
	- если некоторое ребро находится на кратчайшем пути между исходной точкой и ориентиром - по нему идем в первую очередь

Будем использовать неравенство треугольника для нижних оценок пути. Пусть A - один из ориентиров, тогда:
- dist(v, w) >= dist(A, w) - dist(A, v)
- dist(v, w) >= dist(v, A) - dist(w, A)
- dist(v, w) >= max{dist(A, w) - dist(A, v), dist(v, A) - dist(w, A)}
Если более одного ориентира: выбираем лучший (максимальный)
- больше ориентиров - лучшие границы, больше памяти
- хороший ориентир для запроса s->t должен находится до s или за t
- нам нужно выбрать ориентиры, которые будут неплохими для всех запросов
- выглядит логичным выбирать ориентиры на краю дорожной сети

Существуют различные алгоритмы выбора ориентиров:
- Случайный выбор
- Плоскостной: разделим карту на k секторов одинаковой площади; возьмем ориентиром наиболее удаленную точку от центра в каждом секторе. Такой способ подходит, только если граф имеет относительно правильную форму. На практике обычно используется оптимизированная версия.
- Избирательный: добавляет ориентиры по одному, глядя на вершины, которые плохо покрыты текущим набором ориентиров S. 
	- Построим из случайно выбранной вершины r дерево кратчайших путей $T_{r}$. 
	- Весом каждой вершины v в этом дереве назовем разность между истинной длиной пути d(v, r) и нижней оценкой этой длины, полученной по текущему набору ориентиров.
	- Размером вершины v назовем сумму ее веса и размеров всех ее потомков в $T_{r}$. Если поддерево $T_{r}$ с корнем в v содержит ориентир, размер v равен 0.
	- Начиная с максимальной по размеру вершины, пойдем вниз по дереву $T_{r}$ и найдем лист с максимальным размером. Примем его за новый ориентир.
- Поиск максимального покрытия. Основной минус избирательного метода - первый ориентир выбирается случайно и выбор следующих ориентиров будет сильно от него зависеть. Мы можем улучшить найденные ориентиры, если сначала, используя избирательный метод, найдем набор ориентиров в несколько раз больше необходимого, а потом отсеем лишние, минимизируя время запроса. Оценим качество набора ориентиров S основываясь на покрытии дуг. 
	- Будем говорить, что ориентир L покрывает дугу (v, w), если вершина v находится на кратчайшем пути L->w. Те l(v, w)=dist(L, w) - dist(L, v), тогда такой выбор ориентира даст нам нижнюю границу для всех путей, содержащих (v, w). 
	- Если хотя бы один ориентир из S покрывает дугу (v, w), то и весь S покрывает эту дугу. 
	- Это наилучший, но самый медленный метод, задача выбора ориентиров становится NP-полной.

**Reach**
Эта эвристика основывается на интуитивном наблюдении: не стоит посещать локальные дороги, когда мы находимся достаточно далеко и от s и от t.

Пусть вершина v лежит на кратчайшем пути P: s->t. Тогда назовем охватом вершины v относительно P величину r(v, P) = min{dist(s, v), dist(v, t)}. Охватом вершины относительно всего графа наховем величину $r(v)=max_{P}r((v,w), P)$ - максимум по всем кратчайшим путям, содержащим (v, w). 

Заметим, что вершины с большим охватом находятся вблизи середины некоторого длинного кратчайшего пути, те:
- на больших автомагистралях вершины имеют большой охват
- на локальных перекрестках вершины имеют маленький охват

Во время обработки ребра (v, w):
- удалим вершину w, если r(w) < min{d(s, v) + l(v, w), LB(w, t)}
- оценка LB(w, t) должна быть подобрана так, чтобы если бы P=(s, ..., v, w, ..., t) было кратчайшим путем, r(w) было бы больше

Как искать нижнюю оценку длины пути LB(w, t)?
- Явно: Евклидово расстояние, с помощью ориентиров
- Неявно: сделать поиск двунаправленным

Таким образом, будем удалять w, если $r(w)<min(d(s,v)+l(v,w),R_{t})$. Для улучшения результата, нам необходимо сбалансировать прямой и обратный поиск. Рассмотрим препроцессинг:
- на начальном этапе $∀v:r(v)←0$
- для каждой вершины s из V рассмотрим дерево кратчайших путей до всех других вершин $T_{s}$
	- найдем наиболее длинный путь $P_{s\to t}$, содержащий v
	- назовем глубиной вершины $d_{s}(v)$ расстояние от s, высотой вершины $h_{s}(v)$ - расстояние до наиболее далекого потомка вершины
	- тогда, охватом вершины в этом дереве будет величина $r_{s}(v)=min(d_{s}(v),h_{s}(v))$
	- Тогда обновим значение охвата: $r(v) = max(r(v), r_{s}(v))$

Сложность алгоритма O(nm), поэтому он слишком медленный для больших графов и его можно улучшить. Финальная версия препроцессинга будет иметь две фазы:
- основная (строятся частично обработанные деревья и добавляются сокращающие путь ребра)
- отладки (вершины с большим охватом обрабатыаются указанным выше алгоритмом - их гораздо меньше, так что обработка будет быстрой)

Оптимизации: 
- сокращение области поиска: заметим, что нужны вершины с маленьким охватом
- пенальти
- сокращение путей
- удаление пропущенных вершин

**Применение**
Одно из применений - маршрутизация. Например, алгоритм OSPF (Open Shortest Pass First). Каждый маршрутизатор строит некоторый граф и использует алгоритм Дейкстры в чистом виде.

**Свойства A**
- Допустимость - если решение существует, с помощью этого алгоритма оно будет найдено
- Оптимальность - найденное решение всегда оптимально
- Эффективность - не существует в данный момент алгоритмов, которые находят решение быстрее с применением той же эвристической функции. A* в ходе решения раскрывает минимальное кво вершин.

**Ограничения A-star**
- Граф должен быть таким, чтобы в нем можно было рассчитать приближенную оценку расстояния между двумя точками
- Стоимость перехода между узлами положительная
- Точность оценки приближенной стоимости влияет на эффективность A*

**Временная сложность**
Обычно алгоритм A* просматривает только часть вершин. Однако в лабиринтах быстродействие приближается к худшему случаю. Быстродействие алгоритма существенно зависит от данных факторов:
- Точность эвристической функции
- Реализация контейнеров известных и исследованных вершин: наиболее затратными операциями в алгоритме являются операции сложения, изъятия и изменения элементов в списках известных и исследованных вершин. На их быстродействие существенно влияют конкретные реализации этих структур данных.

Пусть имеется множество вершин в графе, информация о вершинах и ребрах доступна до начала работы алгоритма, использованная эвристическая функция - монотонная. Список известных вершин реализован как бинарная куча, список исследованных - как массив. Тогда алгоритм A* имеет квадратичную зависимость от ква вершин графа  и худшее время работы $O(|V|^2)$. 

Функция для получения нижней оценки может быть оптимизирована. Если каджая вершина хранится как указатель на соответствующий объект в куче, то время работы уменьшится с квадратичного до логарифмического, а общее время работы алгоритма - до $O(|V|*\log|V|)$.
(классический A* - на массиве $O(v^2)$, на двоичной куче - O(E logv); ALT - препроцессинг, двоичная куча - $O(k*E*\log v)$, запрос, двоичная куча - $O(E*\log v)$; Reach - препроцессинг - $O(v^2E)$, запрос - тяжело оценить). 
Пространство: $O(v^2)$ или O(v+E) - стандартный; O(kv) - препроцессинг и O(v+E) - запрос, итого O(kv+E) - ALT; O(v) препроцессинг и O(v+E) - запрос, итого O(v+E) - Reach.  
